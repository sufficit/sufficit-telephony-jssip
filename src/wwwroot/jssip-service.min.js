export function GetStatus(){return WebPhone.status}export function onJsSIPLoaded(t){let i=[];t.sockets.forEach(function(n){let t=new JsSIP.WebSocketInterface(n);i.push(t)});t.sockets=i;WebPhone=new JsSIP.UA(t);window.WebPhone=WebPhone;WebPhone.on("connected",n.bind(this,"onConnected"));WebPhone.on("disconnected",n.bind(this,"onDisconnected"));WebPhone.on("newMessage",n.bind(this,"onNewMessage"));WebPhone.on("registered",n.bind(this,"onRegistered"));WebPhone.on("unregistered",n.bind(this,"onUnregistered"));WebPhone.on("registrationFailed",n.bind(this,"onRegistrationFailed"));WebPhone.on("ringing",n.bind(this,"onRinging"));WebPhone.on("ack",n.bind(this,"onAck"));WebPhone.on("newRTCSession",n.bind(this,"onNewRTCSession"));WebPhone.start()}function n(n,t){switch(n){case"onNewRTCSession":t=t.session;t.toJSON=r;break;case"onDisconnected":console.debug(t)}DotNetObjectReference.invokeMethodAsync(n,t)}function r(){var n={};for(const t of["id","direction","status"])n[t]=this[t];return n}export var WebPhone,DotNetObjectReference;let t="media-player-self",i="audio-player-remote";export const Reference=async function(n,t){if(DotNetObjectReference=t,!window.JsSIP){const t=document.getElementById("jssip");t?await window.JsSIPLoading:window.JsSIPLoading=await new Promise(t=>{console.debug("resolving: ",n),CreateScriptTag(n,()=>t(window.JsSIP),document.body)})}await t.invokeMethodAsync("onDependenciesLoaded",window.JsSIP)},CreateScriptTag=function(n,t,i){var r=document.createElement("script");r.id="jssip";r.src=n;r.onload=t;r.onreadystatechange=t;i.appendChild(r)};export const TestDevices=async function(n){console.debug("testing devices request: {0}",n);let t=!1,i;navigator.getUserMedia=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.mozGetUserMedia||navigator.mediaDevices.getUserMedia;const r=new Promise(function(t,i){navigator.getUserMedia(n,t,i)}),u=await r.then(()=>t=!0).catch(n=>i=`(${n.code}) ${n.name} => ${n.message}`);return console.debug("response: ",u),{request:n,success:t,message:i}};export const MediaDeviceUpdate=async function(n,i){console.debug(`MediaDeviceUpdate => ${n} :: ${i}`);switch(n){case"audiooutput":AttachSinkId(i);break;case"videoinput":{let n=document.getElementById(t);n||(n=document.createElement("video"),n.id=t,document.body.appendChild(n));const r=await navigator.mediaDevices.getUserMedia({video:{deviceId:{exact:i}}});"srcObject"in n?n.srcObject=r:n.src=URL.createObjectURL(r);break}}},BrowserOutputSelectSupport=function(){return!("sinkId"in HTMLMediaElement.prototype)},AttachSinkId=function(n){const t=document.getElementById(i);typeof t.sinkId!="undefined"?t.setSinkId(n).then(()=>{console.log(`Success, audio output device attached: ${n}`)}).catch(n=>{let t=n;n.name==="SecurityError"&&(t=`You need to use HTTPS for selecting audio output device: ${n}`);console.error(t);audioOutputSelect.selectedIndex=0}):console.warn("Browser does not support output device selection.")};export const MediaDevices=async function(){if(!navigator.mediaDevices||!navigator.mediaDevices.enumerateDevices){console.warn("enumerateDevices() not supported.");return}return await new Promise(n=>{navigator.mediaDevices.enumerateDevices().then(n).catch(function(n){console.error(n.name+": "+n.message)})})};